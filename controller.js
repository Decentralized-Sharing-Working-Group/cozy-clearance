// Generated by CoffeeScript 1.7.1
var Contact, americano, async, clearance,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

clearance = require('./index');

async = require('async');

americano = require('americano');

Contact = americano.getModel('Contact', {
  fn: String,
  n: String,
  datapoints: function(x) {
    return x;
  }
});

module.exports = function(options) {
  var out, sendMail;
  sendMail = options.sendMail;
  out = {};
  out.details = function(req, res, next) {
    return async.parallel({
      domain: function(cb) {
        return req.doc.getPublicUrl(cb);
      },
      self: function(cb) {
        return cb(null, req.doc.clearance);
      }
    }, function(err, result) {
      if (err) {
        return next(err);
      }
      return res.send(result);
    });
  };
  out.add = function(req, res, next) {
    var autosend, contactid, email, _ref;
    _ref = req.body, email = _ref.email, contactid = _ref.contactid, autosend = _ref.autosend;
    return clearance.add(req.doc, 'r', {
      email: email,
      contactid: contactid
    }, function(err, key) {
      if (err) {
        return next(err);
      }
      if (!autosend || autosend === 'false') {
        return res.send(req.doc);
      } else {
        req.body.key = key;
        return out.send(req, res, next);
      }
    });
  };
  out.revoke = function(req, res, next) {
    var key;
    key = req.body.key;
    return clearance.revoke(req.doc, {
      key: key
    }, function(err) {
      if (err) {
        return next(err);
      }
      return res.send(req.doc);
    });
  };
  out.send = function(req, res, next) {
    var key;
    key = req.body.key;
    return sendMail(req.params.type, req.doc, key, function(err) {
      var newrules;
      if (err) {
        return next(err);
      }
      newrules = req.doc.clearance.map(function(rule) {
        if (rule.key === key) {
          rule.sent = true;
        }
        return rule;
      });
      return req.doc.updateAttributes({
        clearance: newrules
      }, function(err) {
        if (err) {
          return next(err);
        }
        return res.send(req.doc);
      });
    });
  };
  out.change = function(req, res, next) {
    clearance = req.body.clearance;
    return req.doc.updateAttributes({
      clearance: clearance
    }, function(err) {
      if (err) {
        return next(err);
      }
      return res.send(req.doc);
    });
  };
  out.sendAll = function(req, res, next) {
    var sent, toSend;
    toSend = req.body;
    sent = [];
    return async.each(toSend, function(rule, cb) {
      sent.push(rule.key);
      return sendMail(req.params.type, req.doc, rule.key, cb);
    }, function(err) {
      var newClearance;
      if (err) {
        return next(err);
      }
      newClearance = req.doc.clearance.map(function(rule) {
        var _ref;
        if (_ref = rule.key, __indexOf.call(sent, _ref) >= 0) {
          rule.sent = true;
        }
        return rule;
      });
      return req.doc.updateAttributes({
        clearance: newClearance
      }, function(err) {
        if (err) {
          return next(err);
        }
        return res.send(req.doc);
      });
    });
  };
  out.contactList = function(req, res, next) {
    return Contact.request('all', function(err, contacts) {
      if (err) {
        return next(err);
      }
      return res.send(contacts.map(function(contact) {
        var emails, name, simple, _ref, _ref1;
        name = contact.fn || ((_ref = contact.n) != null ? _ref.split(';').slice(0, 2).join(' ') : void 0);
        emails = (_ref1 = contact.datapoints) != null ? _ref1.filter(function(dp) {
          return dp.name === 'email';
        }) : void 0;
        emails = emails.map(function(dp) {
          return dp.value;
        });
        return simple = {
          id: contact.id,
          name: name || '?',
          emails: emails || []
        };
      }));
    });
  };
  return out;
};
